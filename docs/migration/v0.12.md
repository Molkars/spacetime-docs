# Updating your app for SpacetimeDB 0.12

We're excited to release SpacetimeDB 0.12, which includes a major overhaul of our Rust, C# and TypeScript APIs for both modules and clients. In no particular order, our goals with this rewrite were:

- Our APIs should be as similar as possible in all three languages we support, and in clients and modules, so that you don't have to go to a ton of work figuring out why something works in one place but not somewhere else.
- We should be very explicit about what operations interact with the database and how. In addition to good hygiene, this means that a client can now connect to multiple remote modules at the same time without getting confused. (Some day a module will be able to connect to remote modules too, but we're not there yet.)
- Our query APIs should have predictable performance characteristics. An indexed lookup should look different in your code from a full scan, and writing the indexed lookup should be easier. (To be frank, this is mostly a concession to our under-developed query planner. In the future, as we get more sophisticated at optimizing and evaluating queries, we expect to return to a logical query API which abstracts away concerns like indices, but for now we don't want to surprise you with what we do and don't have.)

We think the new APIs are a significant improvement, but they're also new, and there are sure to be some rough edges. If you run into any trouble, please [as us for help or share your feedback on Discord!](https://discord.gg/spacetimedb)

To start migrating, update your SpacetimeDB CLI, and bump the `spacetimedb` and `spacetimedb_sdk` dependency versions to 0.12 in your module and client respectively.

## Modules

### The reducer context

All your reducers must now accept a reducer context as their first argument. In Rust, this is now taken by reference, as `&ReducerContext`. All access to tables now go through methods on the `db` or `Db` field of the `ReducerContext`.

```rust
#[spacetimedb::reducer]
fn my_reducer(ctx: &ReducerContext) {
    for row in ctx.db.my_table().iter() {
        // Do something with the row...
    }
}
```

```csharp
TODO fill in equivalent C# example
```

### Table names and access methods

You now must specify a name for every table, distinct from the type name. In Rust, write this as `#[spacetimedb::table(name = my_table)]`. The name you specify here will be the method on `ctx.db` you use to access the table.

```rust
#[spacetimedb::table(name = my_table)]
struct MyTable {
    #[primary_key]
    #[auto_inc]
    id: u64,
    other_column: u32,
}
```

```csharp
TODO fill in equivalent C# example
```

One neat upside of this is that you can now have multiple tables with the same row type!

```rust
#[spacetimedb::table(name = signed_in_user)]
#[spacetimedb::table(name = signed_out_user)]
struct User {
    #[primary_key]
    id: Identity,
    #[unique]
    username: String,
}
```

```csharp
TODO
```

### Iterating, counting, inserting, deleting

Each "table handle" `ctx.db.my_table()` has methods:

| Rust name | C# name  | Behavior                                |
|-----------|----------|-----------------------------------------|
| `iter`    | `Iter`   | Iterate over all rows in the table.     |
| `count`   | `Count`  | Return the number of rows in the table. |
| `insert`  | `Insert` | Add a new row to the table.             |
| `delete`  | `Delete` | Delete a given row from the table.      |

### Index access

Each table handle also has a method for each BTree index and/or unique constraint on the table, which allows you to filter, delete or update by that index. BTree indices' filter and delete methods accept both point and range queries.

```rust
#[spacetimedb::table(
    name = entity,
    index(name = location, btree = [x, y]),
)]
struct Entity {
    #[primary_key]
    #[auto_inc]
    id: u64,
    x: u32,
    y: u32,
    #[index(btree)]
    faction: String,
}

#[spacetimedb::reducer]
fn move_entity(ctx: &ReducerContext, entity_id: u64, x: u32, y: u32) {
    let entity = ctx.db.entity().id().find(entity_id).expect("No such entity");
    ctx.db.entity.id().update(Entity { x, y, ..entity });
}

#[spacetimedb::reducer]
fn log_entities_at_point(ctx: &ReducerContext, x: u32, y: u32) {
    for entity in ctx.db.entity().location().filter((x, y)) {
        log::info!("Entity {} is at ({}, {})", entity.id, x, y);
    }
}

#[spacetimedb::reducer]
fn delete_faction(ctx: &ReducerContext, faction: String) {
    ctx.db.entity().faction().delete(&faction);
}
```

```csharp
TODO
```

### `query`

Note that the `query!` macro in Rust and the `.Query()` method in C# have been removed. We plan to replace them with something even better in the future, but for now, you should write your query explicitly, either by accessing an index or by chaining `ctx.db.my_table().iter().filter(|row| predicate)`.

### Built-in reducers

The Rust syntax for declaring builtin lifecycles have changed. They are now:

- `#[spacetimedb::reducer(client_connected)]`
- `#[spacetimedb::reducer(client_disconnected)]`
- `#[spacetimedb::reducer(init)]`

## Clients

Make sure to run `spacetime generate` after updating your module!

### The connection object

Your connection to a remote module is now represented by a `DbConnection` object, which holds all state associated with the connection. We encourage you to name the variable that holds your connection `ctx`.

Construct a `DbConnection` via the [builder pattern](https://en.wikipedia.org/wiki/Builder_pattern) with `DbConnection::builder()` or your language's equivalent. Register on-connect and on-disconnect callbacks while constructing the connection via the builder.

### Polling the `DbConnection`

In Rust, you now must explicitly poll your `DbConnection` to advance, where previously it ran automatically in the background. This allows us to work under the variety of exciting constraints imposed by game development - for example, you can now arrange it so that all your callbacks run on the main thread if you want to make GUI calls that care about that sort of thing. You can recreate the previous behavior by calling `ctx.run_threaded()` immediately after buidling your connection. You can also call `ctx.run_async()`, or manually call `ctx.frame_tick()` at an appropriate interval.

C# already made you explcicitly poll your `DbConnection`, so not much has changed there. The `Update()` method is now called `FrameTick()`.

### Subscribing to queries

We're planning a major overhaul of the API for subscribing to queries, but we're not quite there yet. This means that our subscription APIs are currently inconsisent and a bit odd. Pardon the mess!

#### Rust

Subscribe to a set of queries by calling `ctx.subscription_builder().on_applied(|ctx| { ... }).subscribe(["SELECT * FROM my_table", "SELECT * FROM other_table WHERE some_column = 123"]);`. The `on_applied` callback is optional. A known bug means that you should only do this once for any given connection.

#### C#

TODO

#### TypeScript

TODO

### Accessing tables

As in modules, all accesses to your connection's client cache now go through the `ctx.db`. Support for client-side indices is not yet consistent across all our SDKs, so for now you may find that you can't make some queries in clients which you could make in modules. The table handles also expose row callbacks.

### Observing and invoking reducers

Register reducer callbacks and request reducer invocations by going through `ctx.reducers`. For each reducer defined by your module, `ctx.reducers` will have:
- A method `ctx.reducers.my_reducer(args...)`, which invokes the reducer.
- A callback `ctx.reducers.on_my_reducer`, which runs whenever the client is notified that the reducer ran. The specific spelling of callback interfaces differs in our three supported languages, but you get the idea.

### The event context

Most callbacks now take a first argument of type `&EventContext`. This is just like your `DbConnection`, but it has an additional field `event: Event`. `Event` is an enum, tagged union, or sum type which encodes all the different events the SDK can observe. This fills the same role as `ReducerEvent` used to, but `Event` is more specific and more accurate to what actually happened.
